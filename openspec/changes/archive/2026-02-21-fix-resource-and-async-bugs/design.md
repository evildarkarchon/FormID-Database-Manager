## Context

The codebase was generated by an AI agent and contains several structural problems that compound in production: three private copies of `GetSafeTableName` have drifted out of sync (one is missing `OblivionRE`, two are missing `SkyrimLE`/`EnderalLE`/`EnderalSE`/`Fallout4VR` in the overlay switch); Mutagen binary overlays (`IModDisposeGetter`) and game environments (`IGameEnvironment`) are never disposed; the SQLite connection string uses `SqliteCacheMode.Shared` which is incompatible with WAL mode; and `PluginProcessingService` builds the Mutagen game environment from the registry default path rather than the user-specified directory.

The architecture is: `MainWindow` → manual-wired services → `PluginProcessingService` orchestrates → `ModProcessor` / `FormIdTextProcessor` do per-plugin work → `DatabaseService` owns schema/CRUD. No DI container. `InternalsVisibleTo` exposes internals to the test project.

## Goals / Non-Goals

**Goals:**
- Eliminate all identified resource leaks (Mutagen overlays, game environments, `CancellationTokenSource`)
- Fix the `PluginProcessingService` using the wrong game directory for load order
- Consolidate `GetSafeTableName` and `ResolveDataPath` into a single location
- Extend Mutagen overlay switch to cover all supported game releases
- Fix SQLite connection pool configuration for WAL mode
- Replace `VACUUM` with WAL-appropriate end-of-session optimisation
- Remove the fake-async signature on `ProcessModRecordsAsync`
- Fix `GameDetectionService` to distinguish `SkyrimLE`, `EnderalLE`, `EnderalSE`

**Non-Goals:**
- Adding a DI container
- Supporting `OblivionRE` (no Mutagen load-order detection available)
- Changing the SQLite schema or query patterns
- Refactoring the button-as-cancel MVVM pattern in `MainWindow`
- Making `ProcessModRecords` truly async (synchronous SQLite writes are intentional for performance)

## Decisions

### D1 — GameReleaseHelper as a new internal static class

**Decision**: Create `Services/GameReleaseHelper.cs` with `internal static` methods `GetSafeTableName(GameRelease)` and `ResolveDataPath(string)`. Remove the three copies of `GetSafeTableName` and two copies of `ResolveDataPath` from their current hosts.

**Alternatives considered**:
- *Promote `DatabaseService.GetSafeTableName` to `public static`*: Creates a dependency from `ModProcessor` and `FormIdTextProcessor` on `DatabaseService` just for a string mapping — wrong abstraction boundary.
- *Keep copies, add a unit test enforcing parity*: Doesn't prevent future drift; the test itself becomes another thing to maintain.

**Rationale**: `GetSafeTableName` is domain knowledge about `GameRelease` → string mapping. It has no service dependency and belongs in a dedicated helper. `ResolveDataPath` is the same pattern.

---

### D2 — LoadOrder dict built once in PluginProcessingService, not per plugin in ModProcessor

**Decision**: `ModProcessor.ProcessPlugin` signature changes from accepting `IList<IModListingGetter<IModGetter>> loadOrder` to `IReadOnlyDictionary<string, IModListingGetter<IModGetter>> loadOrderDict`. `PluginProcessingService` builds the dict once before the plugin loop.

**Alternatives considered**:
- *Pass `loadOrder` via `ProcessingParameters`*: Would add a Mutagen type to `ProcessingParameters`, coupling the parameter object to the parsing library. `ProcessingParameters` currently contains only primitive/domain types.
- *Cache the dict inside `ModProcessor` as an instance field*: `ModProcessor` is stateless and shared; caching would require thread-safety logic.

**Rationale**: Correct level of abstraction. `PluginProcessingService` owns the loop and the load order; it is the right place to do the O(M) dict build once.

---

### D3 — IModDisposeGetter variable type + using

**Decision**: In `ModProcessor.ProcessPlugin`, change `IModGetter mod = gameRelease switch { ... }` to `using IModDisposeGetter mod = gameRelease switch { ... }`. `ProcessModRecords` continues to accept `IModGetter` (read-only interface is sufficient inside the method).

**Rationale**: `CreateFromBinaryOverlay` returns `IXxxModDisposableGetter` which implements `IModDisposeGetter : IModGetter, IDisposable`. The current `IModGetter` declaration silently widens away `IDisposable`. Each undisposed overlay holds an open `IBinaryReadStream` (file handle or memory map) until GC.

---

### D4 — GameEnvironment disposal via using + correct directory

**Decision** (PluginListManager): `using var env = GameEnvironment.Typical.Builder(...).WithTargetDataFolder(dataPath).Build();` inside the `Task.Run` lambda. `ToList()` materialises the load order before the `using` block exits.

**Decision** (PluginProcessingService): Replace the call to `GameEnvironment.Typical.Construct(parameters.GameRelease)` (which ignores the user's directory) with `GameEnvironment.Typical.Builder(parameters.GameRelease).WithTargetDataFolder(dataPath).Build()` wrapped in `using`. The `dataPath` is resolved via `GameReleaseHelper.ResolveDataPath(parameters.GameDirectory!)`.

**Rationale**: `IGameEnvironment.Dispose()` releases `LoadOrder` file handles and `LinkCache` memory. `GameEnvironmentState` is `sealed`, so `using` is the right pattern. The `PluginListManager` already used `WithTargetDataFolder` correctly — `PluginProcessingService` was the outlier.

---

### D5 — SqliteCacheMode.Default + mmap_size + remove page_size

**Decision**: Change `Cache = SqliteCacheMode.Shared` → `Cache = SqliteCacheMode.Default`. Remove `PRAGMA page_size` from `ConfigureConnection`. Add `PRAGMA mmap_size = 268435456` (256 MB).

**Rationale**: `SqliteCacheMode.Shared` maps to SQLite's URI shared-cache mode, which the SQLite documentation explicitly discourages and which has known read-lock incompatibilities with WAL's snapshot semantics. `Default` (private cache per connection) is what WAL expects. `page_size` is a no-op after the first write — the database file's page size is fixed at creation. `mmap_size` enables memory-mapped reads, reducing latency for large databases without changing write semantics.

---

### D6 — OptimizeDatabase: PRAGMA wal_checkpoint(TRUNCATE) + PRAGMA optimize

**Decision**: Replace `VACUUM` with `PRAGMA wal_checkpoint(TRUNCATE); PRAGMA optimize;`.

**Alternatives considered**:
- *Keep VACUUM*: VACUUM rewrites the entire database file (O(DB size)), acquires an exclusive lock, and is overkill after bulk inserts with no fragmentation. In update mode (delete + insert), free-page reuse makes VACUUM unnecessary.
- *PRAGMA wal_checkpoint(PASSIVE)*: Does not truncate the WAL file; the WAL may remain large.

**Rationale**: `TRUNCATE` checkpoint writes all WAL frames back to the main file and truncates the WAL to zero — achieving the same "clean" end state as VACUUM, at O(WAL size) cost. `PRAGMA optimize` updates query-planner statistics after bulk inserts, which is essential for query performance on the newly populated data.

---

### D7 — ProcessModRecordsAsync → private void ProcessModRecords

**Decision**: Remove the `Task` return type and `return Task.CompletedTask;`. Rename to `ProcessModRecords`. Call site in `ProcessPlugin` becomes a direct synchronous call.

**Rationale**: The method contained no `await` expressions and was not declared `async` (which is how it bypassed the `CS1998` warning-as-error). Returning `Task.CompletedTask` synchronously means the caller's `await` is a no-op scheduling round-trip. The synchronous `ExecuteNonQuery` pattern for SQLite in-process writes is intentional (documented in `FlushBatch`); making this async would add state machine overhead for zero benefit.

---

### D8 — SkyrimLE / EnderalLE / EnderalSE detection heuristic

**Decision**: In `GameDetectionService.DetectGame`, after finding `Skyrim.esm`, apply this detection order:

1. Check for `Enderal - Forgotten Stories.esm` (Enderal master) **first**
   - If present and `SkyrimSE.exe` exists in the game root → `EnderalSE`
   - If present and `TESV.exe` exists → `EnderalLE`
2. Existing GOG / VR checks unchanged
3. Check for `SkyrimSE.exe` → `SkyrimSE`
4. Fallthrough → `SkyrimLE` (implies `TESV.exe` present, no SE executable)

**Rationale**: Enderal uses Skyrim's master file (`Skyrim.esm`) plus its own master, with the same executables as SE/LE. Checking for the Enderal master before the executable avoids misidentifying Enderal as vanilla Skyrim. `SkyrimSE.exe` presence is the reliable discriminator between SE and LE; Skyrim LE uses `TESV.exe`.

---

### D9 — _debounceCts disposal + MainWindowViewModel IDisposable

**Decision**: In `DebounceApplyFilter`, change `_debounceCts?.Cancel();` to `_debounceCts?.Cancel(); _debounceCts?.Dispose();` before reassignment. Implement `IDisposable` on `MainWindowViewModel` to dispose the final `_debounceCts` on teardown.

**Decision**: In `MainWindow`, add `this.Closed += (_, _) => Dispose();` in the constructor.

**Rationale**: `CancellationTokenSource.Cancel()` does not release the `WaitHandle`. `Dispose()` does. On every filter keystroke the old CTS is replaced; without `Dispose()` the handle leaks until GC. `MainWindow.Dispose()` already exists but Avalonia doesn't call it automatically — hooking `Closed` is the idiomatic pattern.

## Risks / Trade-offs

- **`ModProcessor.ProcessPlugin` signature change**: Tests that mock or directly call `ProcessPlugin` with `IList<>` will need updating to pass `IReadOnlyDictionary<>` instead. Low risk — the change is mechanical.
- **Enderal detection heuristic**: Detection relies on file/directory naming conventions that could theoretically differ across Enderal versions or distributions. If `Enderal - Forgotten Stories.esm` changes name in a future release, detection falls back to vanilla Skyrim detection. Mitigation: the detection is heuristic by design; users can always select the game manually if auto-detect fails.
- **`using var env` inside Task.Run lambda (PluginListManager)**: The `env.Dispose()` call happens on the thread pool thread, not the UI thread. `GameEnvironmentState.Dispose()` only releases file handles and the link cache — no UI interaction — so this is safe.
- **Removing VACUUM**: If a user runs many update-mode sessions, the database file may not shrink over time. This is acceptable — SQLite reuses free pages for new inserts. A manual VACUUM option could be added as a future enhancement.

## Open Questions

_(none — all decisions resolved during exploration)_
